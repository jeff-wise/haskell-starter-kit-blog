
---
title: Introduction
time_created: 2017-12-14T00:00:00Z
body: |+

  This tutorial is written with the assumption that the reader is fluent, 
  more or less, with the basic concepts of pure functional programming 
  and Haskell such as referential transparency, algebraic data types, 
  functors, typeclasses, and monad transformers.

  But sometimes we want to learn the hard way. Sometimes, we have to learn 
  the hard way. Life goes fast, and priorities slip away, caught in the 
  current of careers, relationships, and exhaustion that we are all familiar 
  with. Learning Haskell is rewarding, but each level gets harder, and 
  eventually, you might just throw away your controller

  ## Goals

  The code and this tutorial are written with a set of goals in mind.
  The primary goal is to instruct. We want to demonstrate what it takes
  to build a simple web application using Haskell. As we go through the
  code and the tasks involved, there will be a recurring focus on understanding software 
  engineering through the particular trade-offs that Haskell makes as a 
  pure, strongly-typed functional programming language. We are not just
  interested in *how* to build a web application, but *why* we should do
  it with these particular tools and processes. Too often programming
  tutorials focus on the construction and not the engineering. We will
  place equal emphasis on both.

  There are many, many ways to build a blog with Haskell. We've done so
  in a way that facilitates teaching and discussion.
  For example, some of the source code could be written more concisely, but that
  won't help explain Haskell's coding style, and playing code golf
  won't help promote a language with a reputation for being hard to
  understand. Likewise, we could have used less complex libraries, but we
  wanted to showcase what Haskell can do differently and better than other
  languages, as well as generate some useful discussion and insight on
  software engineering in general.

  #### Analyze Engineering Real World Applications with Haskell

  Is pure functional programming better? When is it better? What are its
  advantages when building real world applications? In this tutorial,
  we'll discuss the trade-offs associated with engineering applications
  in Haskell.

  In particular, we'll pursue answers to the following questions:

     * How do you write code that is easy to understand?
     * How do you write code that is easy to extend?
     * How do you write code quickly? How do write code that works the
       first or second time its run?
     * How do you write code with minimum errors?
     * How do you create a web application that is easy to deploy?
     * How do you manage a software project's common tasks and metadata?
     * How do you structure the code in a Haskell web application?

  #### Serve as an Extensible Base for Haskell Web Applications

  This example application is a very basic blog. We could have created
  something more interesting, but the code would be longer and more
  complex. The brevity and relative simplicity of the blog serves the
  project's goals in two ways:

    1. **Generality** The purpose of this project is to teach about building Haskell
       applications in general, but not how to build a specific application. Too many
       details would distract from the more general lessons.
    2. **Extensibility** Because there are few assumptions in the application
       logic, the project can easily be used as a base for a more complicated web
       application.

  #### Promote Haskell

  Haskell is awesome, but often misunderstood. If successful,
  this project will showcase Haskell's strengths and serve as an
  entrypoint to building real Haskell applications.


