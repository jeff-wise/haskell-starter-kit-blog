
---
title: Introduction
time_created: 2017-12-07T00:00:00Z
summary: |+
  ## Ready to start building *and deploying* applications with Haskell?

  This Starter Kit will help you create your own blog powered by Haskell and
  the power of <ins>pure, strongly-typed functional programming</ins>.

  ## What's Here?

   * A cloneable, deployable **Haskell web application** (a blog)
   * A **tutorial** with some mini-essays about Haskell, a in-depth code
       review, and instructions for using and managing the project
   * A set of **exercises** of varying difficulty for learning or
       fine-tuning Haskell programming skills. It's homework that you
       can use when you're done!
   * **Deployment scripts** that can easily be re-used or extended for use
       in other Haskell projects
body: |+
  ## Ready to start building *and deploying* applications with Haskell?

  This Starter Kit will help you create your own blog powered by Haskell and
  the power of <ins>pure, strongly-typed functional programming</ins>.

  Does this tutorial look too long? Want your blog now? Clone this
  repository and follow the instructions in the [I Want My Blog
  Now!](#i-want-my-blog-now) section. In less than fifteen minutes,
  you'll be able to publish your first post:

  <br/>

  ![First post example.](/images/firstpost.png)

  Of course, you can write whatever you'd like.

  ## What's Inside?

    * A cloneable, deployable **Haskell web application** (a blog)
    * A **tutorial** with some mini-essays about Haskell, a in-depth code
        review, and instructions for using and managing the project
    * A set of **exercises** of varying difficulty for learning or
        fine-tuning Haskell programming skills. It's homework that you
        can use when you're done!
    * **Deployment scripts** that can easily be re-used or extended for use
        in other Haskell projects

  ## Why?

  Learning Haskell is difficult. First, you have to *understand*
  a lot of new concepts like algebraic data-types, function currying,
  typeclasses, and monads. Then, you have to learn *how to use* algebraic
  data-types, currying, typeclasses, and monads to build non-trivial
  applications that are both efficient and maintainable. The goal of
  this tutorial isn't to help you understand these Haskell concepts 
  individually, but to help you use them generally, in the process of building
  real-world applications.

  Much of this tutorial is language-agnostic. Great software will
  have similar characteristics regardless of the implementation language
  (or even despite it). Even so, each language has its own vision 
  of how to develop software efficiently, and the best langauges are the
  ones that support a consistent methodology. This tutorial showcases 
  a little bit of Haskell's vision and methodology for software
  development. We'll discuss some common problems in software and show
  how Haskell's type system and expressiveness lead to some fascinating
  solutions.

  If you're new to Haskell, I hope that this project will help you to
  appreciate Haskell's vision for software development and to understand
  why Haskell programmers are so passionate about things like immutablity, 
  types, and abstract mathematics. If you already know a little Haskell 
  (or maybe a lot), then perhaps this project will be useful as a starting point 
  for your next application. Whatever the case, there should be
  something here for everyone. 

  Haskell pushes the limits of software development. It challenges you
  to try new ways of doing something you might already know how to do in
  another language. But it's not just a different syntax, it's a different way of 
  thinking. You'll see old problems in a new way, and the tried-and-true
  solutions that you've relied upon before may start to appear a little
  rusty. It's happened to all of us -- there we are, programming in another
  language, as comfortable and confident as we've always been, when we
  find ourselves thinking about the Haskell approach and wishing we could 
  write a simple `where` clause, curry a function, or do just a little bit 
  of type-level programming.

