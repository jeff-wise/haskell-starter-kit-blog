
---
title: Learning Haskell (A Fictional Memoir)
time_created: 2017-12-08T00:00:00Z
body: |+

  ## Flash Back

  In my first year of high school I joined the programming club. We
  called ourself the The Greys in reference to grey hat hacking, in
  which we rarely did anything illegal but wanted to 

  The club was a bit...boyish. Most members wanted to discuss hacking, 
  the dark net (along with the things one might find there), or 
  video games. Those were interesting conversations, and I quickly made 
  friends, but I felt disappointed. I was expecting 

  I stayed after school with her on Tuesdays and Thursdays. We worked
  alongside each other on separate projects, but we helped each other
  out when we got stuck. 

  Well, she helped me a lot. I was still figuring out the syntax while
  she wrangled with semantics, weaving together complex expressions like an
  artist brushes paint onto a canvas. Her creations were wild landscapes -- 
  jagged mountains and raging seas, dense forests full of ancient towers, 
  and rivers that flowed in patterns and fell from cliffs in torrents.
  
  When I looked at her code, I was lost. I knew I had a lot to learn.

  Only a few weeks had passed before we became good friends, and I came to 
  know her well, her interests outside of programming, and her idiosyncracies. 
  She always wore plaid shirts. She hid her love of country music which she 
  often listend to while programming. She bit her lip when she couldn't 
  figure out how to do something. I never saw a bigger reaction from her, 
  even when she was stuck for hours. She was infinitely patient, squashing
  large bugs the way a dog herds sheep.

  Of course, I had a crush on her, but I was immature, and I had less 
  confidence in myself than in my programming. I did my best to hide my feelings. 
  My feet raced out of control on the way to meet her after school, and my mind 
  raced wild when she talked or was about to leave, and I couldn't think of 
  what to say. I always ended up saying something about programming -- C++ or 
  functions or some non-sense about the OpenGL API. She must have thought 
  that coding was all I thought about.

  I took out my frustration in my projects, staying up late to finish 
  sections of code, in the back of my mind hoping that she might be impressed.
  She was impressed, or at least interested, but her reactions never changed 
  in the way that I was expecting. When we're young, too many of our expectations 
  about life come from t.v. or the movies, but it wasn't until much later 
  that I learned not to expect what I had been expecting. She already knew 
  I liked programming. She never expected anything unexpected from me. 
  
  Our routine continued until February when Sebastian joined the club and 
  Avery invited him to work with us after school on Tuesdays and Thursdays. 
  Truly, Sebastian was a great guy. But he liked Avery too, and he didn't 
  hide it. He was also a better programmer than me, showing off his 
  cross-platform creations with the Java programming language.



  That summer, Avery moved to another school and became a Javascript programmer.
  A long time passed before we met again.


  Eventually, I began to work on bigger and more ambitious projects. I craved  
  a certain aesthetic in my code -- a sense of elegance, structure, 
  and organization that would make me feel comfortable building and maintaining 
  something bigger than what I could fit inside my head.

  I learned that building software is actually very difficult and oftentimes, 
  incredibly frustrating. I started to do something weird - I focused less 
  on what I was building and more on how I was building it. It was like 
  stopping my car in the middle of the race, taking the engine out and 
  trying to tweak it to make it go faster. I knew I wasn't going to catch 
  up. But I did find a new hobby.

  Now that I had my new hobby -- my quest to find more efficient ways to 
  build complex software -- I started researching. I was writing a lot 
  of object-oriented code, so I spent a lot of time investigating design 
  patterns, inheritance, polymorphism, program organization, general, and 
  how to use all of those concepts to build better software. What I found 
  was frustrating. I found a lot of "sage advice" or mottos, quotes or phrases 
  that are often repeated and sound very good, but are very rarely substantiated. 
  Sometimes I found them to very well substantiated in specific contexts, but 
  not in general. I also found a lot of design patterns or "framework" patterns 
  like MVC. These also looked good initially, were intuitive and appealed to 
  an aesthetic sense of organization that I had, but I could never find a 
  good argument as to why they were better. I wasn't aware at the time, but 
  I was searching for some sort of underlying mathematical logic or structure, 
  some set of consistent principles that I could use to reason about how to 
  bulild good software, but I couldn't find them.

  ## Academic Problems

  I sat down at a table full of well-known names, thirsting for
  knowledge. I turned to OOP, and I asked him "How do I write good
  software?" 

  He replied between sips of coffee, "You only need polymoprhism"


  ## A Search Algorithm

  I stood up to leave, feeling hungry and lost. Perhaps I had been
  naive. Perhaps I had wasted time researching and studying blueprints,
  when I could have already built a castle, one stone after another,
  like legos, fitting the pieces together and tearing them apart until
  it looked like what I wanted. My wall of books would be a wall of trophies.

  I needed some fresh air. I decided to go on a trip to get some
  perspective. I grabbed the MOTOR framework diagram as a I left, in case 
  I had any car troubles, and headed north to seek some solitude and 
  look inward for a little while.
  packed bags of books on programming

  The roads were long and winding, filled with sudden hair-pin turns
  that smoked my brakes and tiring climbs up switchbacks where my engine
  whined and grew hot, but persisted with the pedal to the floor. 

  After some time the road evened out, unwinding like the straight end
  of a tangled cord. I saw
  rolling hills and thickets of trees, small farms and fields of crops.
  I passed an apple orchard and a pen of goats climbing on wooden
  platforms. There was a lake with carribean blue water, and along its 
  undulating shoreline houses rested serenely in the shade of lakeside trees 
  and white boats lounged in the waves, sunbathing.

  The day grew later. I saw more farms and fields. I saw more orchards
  and another pen of goats. And I saw the lake, again, its beautiful blue
  waters distinct in my mind. 

  I had not taken a single turn from the road, but before the lake had
  left my mind, I saw again the orchard, red apples in the rows of
  trees, and the goats, still playfully climbing. Before I saw the lake
  again, I knew that I was going in a loop, stuck in a cycle. But as
  I drove on, I could not find a single turn. There was no way out. 

  I drove for another hour or two. I counted the goats in the pen, and
  picked out my favorite houses along the lake. I thought about stopping
  to pick an apple, but I figured it was best to keep on as the sun had
  passed its highest point and was retreating to the horizon. The goats
  disappeared, and the brilliance of the lake dulled as shadows
  stretched over the water from the trees and houses.

  Just as a I ran out of gas, I found myself in a small town called Base Case.
  I filled my car at the only gas station, still perplexed. As
  I stretched my legs and rolled my neck in an effort to ease the aches
  of driving, I realized that I was still hungry -- and quite thirsty too. I drove down 
  Main street, looking for something to eat. Only a minute had passed before 
  I reached the other side of the small town where I found a small 
  restaurant: Haskell's Curry. I was in the mood for something spicy,
  and maybe a little tangy -- something *different*. Perfect, I thought.

  ## Sojourn - Biased Bits

  Programming languages are a means of communication between humans and 
  computers, or more accurately, humans and the universe. That is -- 
  we don't say "Hi!" or "I love you" to a computer, but rather, we tell 
  it patterns that it should use to manipulate electrical currents flowing 
  through the processor and memory. There are infinite languages one could 
  write to describe these patterns, but there are only so many that humans 
  can use. Can we categorize these possible languages? Can we make an 
  assessment of which ones are better than others? We can definitely 
  categorize them.

  It's hard to assess programming languages. One reason is that they are 
  often made with different goals in mind, and it's no use comparing apples 
  and oranges. They're both good, but one's sweet and one's citrus. A more 
  interesting dilemma in comparing languages is also true with apples and 
  oranges -- they're subjective. It depends on your taste, or maybe even your 
  mood. While programming languages are built with the objective to give 
  instructions to a computer, how exactly those intructions are expressed can 
  vary as much as people themselves vary. There's a business language, a lazy 
  language, a try-hard language, a sassy language, a he's-just-going-through-a-phase 
  language, etc... Languages and other development tools are made by people, 
  for people. This is one reason why we end up with so many different languages 
  as well as code editors, tools, frameworks, and libraries. The other reason 
  is of course technical. Sometimes one way of doing something is better than 
  another way, and we hope that there are objective means of comparing options. 
  How can we assess these options objectively?

  # Paradigm Shift

  I realized that a lot of software development is done in a manner that 
  appeals to our intuition. It creates structures and processes that are 
  easy to understand and manipulate. This is an effective method -- it's 
  simply optimizing programming for the natural way that humans think. 
  Unfortunately -- and I'll be the first to admit -- humans aren't as 
  smart as they like to believe, and what's intuitive for us is very 
  rarely optimal. During my search, I found that I wasn't compeled by 
  intuitive solutions. They were fun, sure, and I enjoyed programming with 
  them, but I always felt like something was missing.

  I thought that maybe, instead of designing tools to be easy to use,
  why not design them to be simple

  Before I set out on this trip, 
  I wanted to understand the mathematics behind software engineering, if there 
  were any. I wanted some sense of objectivity about how to build better software, 
  it there was any to be found. When I discovered Haskell and started learning it, 
  I didn't know that my search was over (at least for awhile). I didn't believe 
  that there were objective ways to understand software development. In that respect, 
  Haskell really changed the way I thought about programming. It put a new ceiling 
  to software development in my eyes, a new mountain to climb, and I was surprised 
  that I was so excited to work hard and reach that new persepctive.

  The way back was easier and less peculiar. I passed the lake, the goats, the orchid, 
  and the farms, but they all receded in the review view mirror, never reappearing. 
  Now, I was on a specific path, a destination in my mind.


  ## Feeling the Side Effects

  It took me a long time to become proficient 
  with Haskell. I didn't come into Haskell with a strong background in 
  abstract or discrete mathematics. In fact, I didn't truly appreciate math at 
  all before learning Haskell. Haskell introduced me into mathematical thinking 
  before I had ever written any proofs, and it did so in a way that was gradual 
  and intuitive, because it was through the process of programming. While many 
  that learn Haskell are attracted to it from their perspectives gained as 
  mathematicians, many are like me, coming at it from the other direction. 
  Both paths are valid routes to Haskell, and it's Haskell's place at this 
  intersection that it makes it both scholarly and pragmatic, a language that 
  can implement ideas from research papers and then immmediately put them into 
  practice building high-quality software.

  At it's core, there's nothing experimental about Haskell. It's an ML-dialect, 
  and therefore an implementation of the [Polymorphic Lambda Calculus][poly-lambda-calculus]. 
  It's not trivial to understand, but it's also not that difficult. It's a 
  simple model of computation, one derived in parallel to Turing's abstract 
  machine. This simplicity shines through in many applications, but it also 
  stands out when the code grows in complexity. You may be doing fine with 
  Haskell when it comes to writing simple, pure functions, but as soon as you 
  try to connect your code to the real-world, you may quickly get overwhelmed. 
  In a way, languages such as Java actually provide useful abstractions that 
  make writing interactive or graphical applications easier, in the sense that 
  they abstract over the underlying mathematical model by providing mutability 
  and free use of I/O in the code. Haskell chose to keep its model pure, but 
  the trade-off is that Haskell was forced to model state mutation and IO 
  using only pure functions, and this is largely where Haskell programming 
  becomes difficult to learn. I'm talking about Monads.

  It definitely seems like a problem when ubiqutious concepts in Haskell 
  like Monads are notoriously difficult to understand. It is true that most 
  Haskell beginners run into trouble with Monads, and well, they should. The 
  interface itself isn't complicated, but the way that they are used can be 
  fairly complex. When using monad transformers, you may likely be applying 
  functions with types that stretch across the screen, and you may be doing 
  operations over values that involve manipulating those complex types either 
  by adding more types, removing types, or modifying types inside the types. 
  It's a lot to keep track of in your head, especially when you're just
  starting out with Haskell.
  But with practice you will develop the mental model and visualization 
  skills that you need to easily write code with complex types. And it's worth it.

  Design patterns in Haskell are mostly just pre-established mathematical 
  structures and algorithms. The library ecosystem is full of implementations 
  of really audacious ideas that work fantasically and would be impossible or 
  impractical to implement in many other languages. This project demonstrates 
  some examples with [Aeson][aeson-stackage], [Servant][servant-docs], 
  and [Opaleye][opaleye-stackage].

  All this being said, if you spend any time reading Haskell discussions online, 
  you'll see that more than a few problems are far from solved. You'll also see 
  a smart, passionate community actively engaged in solving these problems. That 
  passion comes from a confidence in the power of the langauge to think about 
  these problems and encode elegant solutions.


